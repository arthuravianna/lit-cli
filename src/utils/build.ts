import fs from 'fs';
import path from 'path';
import ipfsOnlyHash from 'ipfs-only-hash';
import esbuild from 'esbuild'



function getBundledVincentAbilityCode() {
  return `/**
 * DO NOT EDIT THIS FILE. IT IS GENERATED ON BUILD.
 */

import { asBundledVincentAbility } from '@lit-protocol/vincent-ability-sdk';
import { vincentAbility } from '../lib/vincent-ability';
import metadata from './vincent-ability-metadata.json';

if(!metadata.ipfsCid) {
  throw new Error('ipfsCid is not defined in metadata JSON file');
}

export const bundledVincentAbility = asBundledVincentAbility(vincentAbility, metadata.ipfsCid);
`;
}


function metadataJsonFile({ ipfsCid }: { ipfsCid: string }) {
  return `{
  "ipfsCid": "${ipfsCid}"
}
`;
}

export const createBundledAbilityFile: esbuild.Plugin = {
  name: 'create-vincent-bundled-ability-file',
  setup(build) {
    build.initialOptions.write = false;

    const entryPoints = build.initialOptions.entryPoints;
    if (!entryPoints) {
        throw new Error('Entry points are not defined');
    }

    if (!Array.isArray(entryPoints) || !entryPoints.every(entry => typeof entry === 'string')) {
        throw new Error('Entry points must be an array of strings');
    }

    if (entryPoints.length === 0) {
        throw new Error('No entry points provided');
    }

    const sourceDir = path.dirname(entryPoints[0]);

    console.log(sourceDir);
    build.onEnd(async (result) => {
        if (result.errors.length > 0) {
            console.error('Build failed with errors:', result.errors);
            return;
        }

        if (!result.outputFiles || result.outputFiles.length === 0) {
            throw new Error('No output files generated');
        }

        const outputFile = result.outputFiles[0];
        const content = outputFile.text;
        const ipfsCid = await ipfsOnlyHash.of(content);

        // Write bundledAbility wrapper
        const bundledSource = getBundledVincentAbilityCode();
        const bundledPath = path.join(sourceDir, '../generated/vincent-bundled-ability.ts');
        fs.writeFileSync(bundledPath, bundledSource);

        // Write metadata JSON
        const outputPath = path.dirname(path.resolve(outputFile.path));
        const metadataPath = path.join(outputPath, 'vincent-ability-metadata.json');
        const metadataContent = metadataJsonFile({ ipfsCid });
        fs.writeFileSync(metadataPath, metadataContent);
    });
  },
};

export const wrapIIFEInStringPlugin: esbuild.Plugin = {
  name: 'wrap-iife-in-string',
  setup(build) {
    build.initialOptions.write = false;

    build.onEnd(async (result) => {
        if (result.errors.length > 0) {
            console.error('Build failed with errors:', result.errors);
            return;
        }

        if (!result.outputFiles || result.outputFiles.length === 0) {
            throw new Error('No output files generated');
        }
        
        const outputFile = result.outputFiles[0];
        const content = outputFile.text;
        const ipfsCid = await ipfsOnlyHash.of(content);

        const wrapped = litActionModuleCode({ content, ipfsCid });
        const outputPath = path.resolve(outputFile.path);
        ensureDirectoryExistence(outputPath);
        fs.writeFileSync(outputPath, wrapped);
    });
  },
};

function litActionModuleCode({ ipfsCid, content }: { ipfsCid: string; content: string }): string {
  return `/**
 * DO NOT EDIT THIS FILE. IT IS GENERATED ON BUILD.
 * @type {string}
 */
const code = ${JSON.stringify(content)};
module.exports = {
  "code": code,
  "ipfsCid": "${ipfsCid}",
};
`;
}

const ensureDirectoryExistence = (filePath: string) => {
    const dirname = path.dirname(filePath);
    if (!fs.existsSync(dirname)) {
        fs.mkdirSync(dirname, { recursive: true });
    }
};